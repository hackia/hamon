#include "HamonCube.hpp"
#include "HamonNode.hpp"
#include "Hamon.hpp"
#include "Make.hpp"
#include <iostream>
#include <vector>
#include <unistd.h>
#include <sys/wait.h>
#include <thread>
#include <cmath>
#include <fstream>
#include <filesystem>
#include <limits>
#include <clocale>
#include <libintl.h>

using namespace Dualys;

#ifndef I18N_GETTEXT_DEFINED
#define _(String) gettext(String)
#define I18N_GETTEXT_DEFINED
#endif

int largest_power_of_two(const unsigned int n) {
    if (n == 0)
        return 0;
    return static_cast<int>(pow(2, floor(log2(n))));
}

std::vector<NodeConfig> generate_configs(const int node_count) {
    std::vector<NodeConfig> configs;
    configs.reserve(static_cast<std::size_t>(node_count));
    for (std::size_t i = 0; i < static_cast<std::size_t>(node_count); ++i) {
        NodeConfig cfg;
        cfg.id = static_cast<int>(i);
        cfg.role = i == 0 ? "coordinator" : "worker";
        cfg.ip_address = "127.0.0.1";
        cfg.port = 8000 + static_cast<int>(i);
        configs.push_back(cfg);
    }
    return configs;
}



void run_node_process(const int node_id, const int node_count, const std::vector<NodeConfig> &configs) {
    const HamonCube cube(node_count);
    HamonNode node(cube.getNode(static_cast<std::size_t>(node_id)), cube, configs);
    node.run();
}

// --- Orchestrateur ---

static std::string prompt(const std::string &q, const std::string &def = {}) {
    std::cout << q;
    if (!def.empty()) std::cout << " [" << def << "]";
    std::cout << ": ";
    std::string s;
    std::getline(std::cin, s);
    if (s.empty()) return def;
    return s;
}

static bool write_text_file(const std::filesystem::path &p, const std::string &content, bool overwrite) {
    if (!overwrite && std::filesystem::exists(p)) {
        std::cerr << "File already exists: " << p << " (won't overwrite)\n";
        return false;
    }
    std::ofstream ofs(p);
    if (!ofs) return false;
    ofs << content;
    return ofs.good();
}

int main(const int argc, char **argv) {
    // If an .hc file path is provided as the first argument, run its @phase tasks and exit.
    if (argc > 1) {
        const std::string arg1 = argv[1];
        if (arg1 == "init") {
            // Initialize i18n for the init flow
            setlocale(LC_ALL, "");
            bindtextdomain("hamon", "./locale");
            textdomain("hamon");

            const unsigned hw = std::thread::hardware_concurrency();
            const int def_nodes = largest_power_of_two(hw > 0 ? hw : 1);
            std::string def_name = "make.hc";
            std::string fname = prompt(_("Name of the .hc file to create"), def_name);
            if (fname.empty()) fname = def_name;
            if (fname.rfind(".hc") == std::string::npos) fname += ".hc";

            std::string nodes_s = prompt(_("Number of nodes (@use), power of 2"), std::to_string(def_nodes > 0 ? def_nodes : 1));
            int nodes = def_nodes;
            try { nodes = std::stoi(nodes_s); } catch (...) {}
            if (nodes <= 0) nodes = def_nodes > 0 ? def_nodes : 1;

            std::string topology = prompt(_("Topology (@topology)"), "hypercube");
            if (topology.empty()) topology = "hypercube";

            std::string host = prompt(_("IP/host for @autoprefix"), "127.0.0.1");
            if (host.empty()) host = "127.0.0.1";
            std::string base_port_s = prompt(_("Base port for @autoprefix"), "9000");
            int base_port = 9000; try { base_port = std::stoi(base_port_s); } catch (...) {}
            if (base_port <= 0) base_port = 9000;

            std::string jobname = prompt(_("Job name (@job)"), "BuildHamon");
            std::string want_example = prompt(_("Add example phases to build this project? (y/n)"), "y");
            bool with_examples = !want_example.empty() && (want_example[0] == 'y' || want_example[0] == 'Y' || want_example == "1");

            // Generate content
            std::ostringstream hc;
            hc << _("# Hamon config generated by 'hamon init'\n");
            hc << "@use " << nodes << "\n";
            hc << "@topology " << topology << "\n";
            hc << "@autoprefix " << host << ":" << base_port << "\n\n";
            // Nodes
            hc << _("# Roles\n");
            for (int i = 0; i < nodes; ++i) {
                if (i == 0) hc << "@node " << i << " @role coordinator\n"; else hc << "@node " << i << " @role worker\n";
            }
            hc << "\n@job " << (jobname.empty() ? std::string("Job1") : jobname) << "\n";
            if (with_examples) {
                hc << "  @phase Compile by=[0] task=\"g++ -std=c++26 -Wall -Wextra -Wpedantic -Wshadow -Wformat=2 -Wconversion -Wsign-conversion -Werror -c main.cpp -o main.o\"\n";
                hc << "  @phase Link to=[0] task=\"g++ *.o -o hamon\"\n";
            } else {
                hc << _("  # Add your phases here, e.g.: @phase Step by=[*] task=\"echo hello\"\n");
            }
            hc << "@end\n";

            std::filesystem::path outp = fname;
            bool overwrite = false;
            if (std::filesystem::exists(outp)) {
                std::string ow = prompt(_("File already exists. Overwrite? (y/n)"), "n");
                overwrite = !ow.empty() && (ow[0] == 'y' || ow[0] == 'Y');
            }
            if (!write_text_file(outp, hc.str(), overwrite)) {
                std::cerr << _("Failed to write file: ") << outp << "\n";
                return 1;
            }
            std::cout << _("File created: ") << std::filesystem::absolute(outp) << "\n";
            std::cout << _("Run: hamon ") << outp.string() << "\n";
            return 0;
        }
        // Otherwise assume it's an .hc path
        const std::string &hc_path = arg1;
        std::cout << "Running @phase tasks from '" << hc_path << "'..." << std::endl;
        const bool ok = Make::build_from_hc(hc_path);
        return ok ? 0 : 1;
    }

    std::cout << "Orchestrator starting..." << std::endl;

    int node_count = 0;
    std::vector<NodeConfig> configs;

    // 1. Detect hardware and generate default config
    const unsigned int hardware_cores = std::thread::hardware_concurrency();
    node_count = largest_power_of_two(hardware_cores > 0 ? hardware_cores : 1);

    if (node_count == 0) {
        std::cerr << "Not enough hardware cores detected to run." << std::endl;
        return 1;
    }
    std::cout << "Detected " << hardware_cores << " cores. Using " << node_count << " nodes." << std::endl;
    configs = generate_configs(node_count);

    // 2. Launch child processes
    std::vector<pid_t> childPids;
    childPids.reserve(static_cast<std::size_t>(node_count));
    for (std::size_t i = 0; i < static_cast<std::size_t>(node_count); ++i) {
        const pid_t pid = fork();
        if (pid == 0) {
            // Child process
            run_node_process(static_cast<int>(i), node_count, configs);
            _exit(0);
        }
        if (pid > 0) {
            childPids.push_back(pid);
        } else {
            std::cerr << "Failed to fork process for Node " << i << std::endl;
        }
    }

    // 3. Wait for all processes to finish
    std::cout << "All " << childPids.size() << " nodes launched. Waiting for them to finish." << std::endl;
    for (const pid_t pid: childPids) {
        waitpid(pid, nullptr, 0);
    }

    std::cout << "All nodes have finished. Orchestrator shutting down." << std::endl;
    return 0;
}
